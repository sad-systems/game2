/*==============================================================================
 *  Title      : Map manager
 *  Author     : Digger (c) SAD-Systems <http://sad-systems.ru>
 *  Created on : 26.05.2016
 *==============================================================================
 */

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var instances = {}, //--- Hash of instances
    instanceDefaultId = 'default';

var basic = require('basic');

/*
var clearTile = function(tile) {
    tile.index = 0;
    tile.alpha = 0;
    tile.layer.dirty = true;
    //tile.destroy();
};
*/    

//==============================================================================
// The Class
//==============================================================================

/**
 * Constructor
 * 
 * @param   {object} options    The JS object with initial class parameters
 * @returns {object}            A new instance of this class
 */
var __theClass = function (options) {

    this.game        = null;
    this.maps        = null;
    this.map         = null;
    this.objects     = null;
    this.layers      = null;
    this.prizes      = null;
    this.blocks      = null;
    this.startPoint  = null;
    this.mainMapName = '';
    
    this._init(options);
    
    return this;

};

//==============================================================================
// Config
//==============================================================================

__theClass.prototype.assetsRootPath = 'assets/';

//==============================================================================
// Protected
//==============================================================================

/**
 * Initialization
 * 
 * @protected
 * @param {object} options  The JS object with initial class parameters
 */
__theClass.prototype._init = function (options) {

    //--- Extend the instance:
    Phaser.Utils.extend(true, this, options);

};

__theClass.prototype.makeSpriteFromTile = function (tile, tilemap, game) {
    var tilesetIndex = tilemap.tiles[tile.index][2],
        tileset      = tilemap.tilesets[tilesetIndex],
        sprite       = game.make.sprite(tile.worldX, tile.worldY, tileset.name, tile.index - tileset.firstgid);
        if (tile.properties) sprite.properties = tile.properties;
        sprite.parentMapLayer = tile.layer.name;
    return sprite;
    //map.createFromTiles(layer.data[row][cell].index, -1, 'P1', i, prizes); //, properties)
};

__theClass.prototype.resizeMap = function () {
    for(var i in this.layers.all) {
        this.layers.all[i].resize(this.game.width, this.game.height);
    }
};

//==============================================================================
// Public
//==============================================================================

__theClass.prototype.createMap = function (mapName) {
    
    mapName = mapName || this.mainMapName;
    
    //--- Create tilemap:     
    var map = this.map = this.game.add.tilemap(mapName);
    //  map.setTileIndexCallback([53,54,55,56,57,58,59,60,61], this.g_etPrize, this, 'Prizes');
    //--- Add tilesets:
    for (var i=0; i<map.tilesets.length; i++) {
        var tileset  = map.tilesets[i];
        map.addTilesetImage(tileset.name, tileset.name); // map.addTilesetImage('Blocks', 'mapLevel1tiles1');
    }             
    //--- Create layers:
    this.layers = {
        platforms: [],
        stairs:    [],
        goods:     [],
        all:       []
    };
    for (var i=0; i<map.layers.length; i++) {
        //--- Create only visible:
        if (!map.layers[i].visible) continue; 
        var worldLayer = map.createLayer(i); //console.log(worldLayer);
        var layer = worldLayer.layer; //map.layers[i];
        this.layers.all.push(worldLayer); //--- Keep all
        if (layer.properties) {
            //--- Platforms:
            if (layer.properties['platform']) {
                this.layers.platforms.push(worldLayer);
                //--- Find collision tiles:
                var collisions = []; //console.log(layer.data);
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) collisions.push(layer.data[row][cell].index); 
                    }
                }
                //--- Set collisions:
                if (collisions.length > 0) 
                    map.setCollision(collisions, true, i);
            }
            //--- Stairs:
            if (layer.properties['stair']) { 
                this.layers.stairs.push(worldLayer);
            }
            //--- Prizes:
            if (layer.properties['prize']) {
                var prizes = this.prizes = this.game.add.group();
                    prizes.enableBody = true;
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) {
                            var tile = layer.data[row][cell];
                            prizes.add(this.makeSpriteFromTile(tile, this.map, this.game));
                            tile.index = -1; //--- clear tile
                        }
                    }
                }                        
            }
            //--- Blocks:
            if (layer.properties['block']) {
                var blocks = this.blocks = this.game.add.group();
                    blocks.enableBody    = true;
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) {
                            var tile = layer.data[row][cell];
                            var sprite = this.makeSpriteFromTile(tile, this.map, this.game);
                            blocks.add(sprite);
                            sprite.body.mass      = 100; //blockMass;
                            sprite.body.gravity.y = 300; //blockGravity;
                            sprite.body.bounce.y  = 0.3; //blockBounce;
                            sprite.body.collideWorldBounds = true;
                            tile.index = -1; //--- clear tile
                        }
                    }
                }
            }
            //--- Goods:
            if (layer.properties['goods']) {
                this.layers.goods.push(worldLayer);
            }
        }
    };

    //--- Resize the world (by the first):
    if (this.layers.all[0])
        this.layers.all[0].resizeWorld(); //console.log(this.map.getLayerIndex('Platforms'));

    //--- Start point:
    this.startPoint = { x:this.game.width/2 , y:this.game.height/2 };

    //--- Game objects:
    this.objects = {
        doors: {}
    };
    for (var name in map.objects) {
        var objs = map.objects[name];
        for (var j in objs) {
            var obj = objs[j];
            //--- Start point:
            if (obj.type == 1) {
                this.startPoint = { x:obj.x, y:obj.y };
            }
            //--- Exit point:
            if (obj.type == 2) {
                this.exitPoint = { x:obj.x, y:obj.y };
            }                    
            //--- Door & Gates:
            if (obj.properties && (typeof(obj.properties.lock) != 'undefined' || obj.properties.gate_target)) {
                this.objects.doors[obj.name] = obj;
            }
            //----------
        };
    };
    
    return this.map;
};

//------------------------------------------------------------------------------
// Scene main methods
//------------------------------------------------------------------------------

__theClass.prototype.preload = function (game) {
    
    this.game = game;
    
    // Level talemap: --------------------------------------------------
    if (this.maps && typeof(this.maps) === 'object') {
        for (var mapName in this.maps) {
            if (!this.mainMapName) this.mainMapName = mapName;
            //console.log('level name:'+mapName+' : '+levelMaps[mapName]);
            var levelMap = require(this.maps[mapName]); //('../tilemaps/level1.json');
            this.game.load.tilemap(mapName, null, levelMap, Phaser.Tilemap.TILED_JSON);
            for (var i=0; i<levelMap.tilesets.length; i++) {
                var tileset  = levelMap.tilesets[i],
                    image    = tileset.image;
                image = image.replace(new RegExp('^[\.\/]*' + RegExp.escape(this.assetsRootPath)), this.assetsRootPath);
                //this.game.load.image(tileset.name, image);  //console.log(tileset);
                this.game.load.spritesheet(tileset.name, image, tileset.tilewidth, tileset.tileheight);  //console.log(tileset);
            }
        }
    }
    //this.game.load.image  ('mapLevel1tiles1', 'assets/sprites/tiles/Blocks.gif');
    //------------------------------------------------------------------    

    
};

//__theClass.prototype.create = function (options) {
//};

__theClass.prototype.update = function () {
    

};

//==============================================================================
// Exports module values:
//==============================================================================

module.exports = {
    
    /**
     * The class to inherit
     * 
     * example:
     * 
     * function childClass() {
     *      theclass.apply(this, arguments);
     * }
     * 
     * childClass.prototype = Object.create(theclass.prototype);
     * childClass.prototype.constructor = childClass;
     * 
     */
    theclass: __theClass,
    
    /**
     * The class factory
     * 
     * @param   {object} options The JS object with initial class parameters
     * @returns {object}         A new instance of this class
     */
    create: function (options, id) {

        if (!id)
            id = instanceDefaultId;
        if (!instances[id]) {
            instances[id] = new __theClass(options);
            instances[id].id = id;
        } else {
            instances[id]._init(options);
        }
        return instances[id];

    },
    
    getInstances: function () {
        return instances;
    }

};