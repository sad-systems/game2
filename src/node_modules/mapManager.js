/*==============================================================================
 *  Title      : Map manager
 *  Author     : Digger (c) SAD-Systems <http://sad-systems.ru>
 *  Created on : 26.05.2016
 *==============================================================================
 */

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var basic        = require('basic'),
    stateStorage = require('stateStorage').getInstance();

/*
var removeTile = function(tile) {
    tile.index = 0;
    tile.alpha = 0;
    tile.layer.dirty = true;
    //tile.destroy();
};
*/    

//==============================================================================
// The Class
//==============================================================================

/**
 * Constructor
 * 
 * @param   {object} options    The JS object with initial class parameters
 * @returns {object}            A new instance of this class
 */
var __theClass = function (options) {

    this.game        = null;
    this.group       = null;
    this.maps        = null;
    this.map         = null; //<--- the current map
    this.objects     = null;
    this.layers      = null;
    this.prizes      = null;
    this.blocks      = null;
    this.startPoint  = null;
    this.mainMapName = '';
    
    this._init(options);
    
    return this;

};

//==============================================================================
// Config
//==============================================================================

__theClass.prototype.assetsRootPath = 'assets/';

__theClass.prototype.blockManager   = null;

//==============================================================================
// Protected
//==============================================================================

/**
 * Initialization
 * 
 * @protected
 * @param {object} options  The JS object with initial class parameters
 */
__theClass.prototype._init = function (options) {

    //--- Extend the instance:
    Phaser.Utils.extend(true, this, options);

};

__theClass.prototype.makeSpriteFromTile = function (tile, tilemap, game) {
    tilemap = tilemap || this.map;
    game    = game    || this.game;
    var tilesetIndex = tilemap.tiles[tile.index][2],
        tileset      = tilemap.tilesets[tilesetIndex],
        sprite       = game.make.sprite(tile.worldX, tile.worldY, tileset.name, tile.index - tileset.firstgid);
        if (tile.properties) sprite.properties = tile.properties;
        sprite.parentMapLayer = tile.layer.name;
    return sprite;
    //map.createFromTiles(layer.data[row][cell].index, -1, 'P1', i, prizes); //, properties)
};

__theClass.prototype.resizeMap = function () {
    for(var i in this.layers.all) {
        this.layers.all[i].resize(this.game.width, this.game.height);
    }
};

//==============================================================================
// Public
//==============================================================================

__theClass.prototype.removeTile = function(tile) {
    stateStorage.save(['tiles', tile.layer.name, tile.x, tile.y, 'remove', tile.index]);
    return this.map.removeTile(tile.x, tile.y, tile.layer.name);
    // tile.index = -1;
    // tile.layer.dirty = true;
    //tile.alpha = 0;
    //tile.destroy();
};

__theClass.prototype.addTile = function(tile, x, y, inCells, layer) { 
    layer = layer || tile.layer.name;
    if (!inCells) {
        x = Math.floor(x / tile.width);
        y = Math.floor(y / tile.height);
    }
    stateStorage.save(['tiles', tile.layer.name, x, y, 'add', tile.index, tile.properties]);
    var newtile = this.map.putTile(tile.index, x, y, layer);
        if (tile.properties) newtile.properties = tile.properties;
    return newtile;
    //tile.alpha = 0;
    //tile.index = -1;
    //tile.layer.dirty = true;
    //tile.destroy();
};

__theClass.prototype.createMap = function (mapName) {

    this.group = this.game.add.group(); //this.group || this.game.add.group();
    return this.newMap(mapName);
    
};

__theClass.prototype.changeMap = function (mapName) {

    return this.newMap(mapName);
    
};


__theClass.prototype.newMap = function (mapName) {
    
    mapName = mapName || this.mainMapName;
    
    this.blockManager = this.blockManager || require('blockManager');
    
    //console.log('map:'+mapName);
    //--- Clear the old map:
    if (this.map) {
        if (this.layers && this.layers.all) {
            for (var i in this.layers.all) { 
                this.layers.all[i].destroy();
            }
        }
        this.prizes.destroy();
        this.blocks.destroy();
        this.map.destroy();
        this.objects = null;
    }
    
    //--- Create tilemap:     
    var map = this.map = this.game.make.tilemap(mapName);
    //--- Init stateStorage:
    stateStorage.init({currentMapName:mapName});
    
    //  map.setTileIndexCallback([53,54,55,56,57,58,59,60,61], this.g_etPrize, this, 'Prizes');
    //--- Add tilesets:
    for (var i=0; i<map.tilesets.length; i++) {
        var tileset  = map.tilesets[i];
        map.addTilesetImage(tileset.name, tileset.name); // map.addTilesetImage('Blocks', 'mapLevel1tiles1');
    }             
    //console.log(this._maps[mapName]);
    //--- Prizes & Blocks:
    this.prizes = null;
    this.blocks = null;
    //--- Layers:
    this.layers = {
        platforms: [],
        stairs:    [],
        goods:     [],
        all:       []
    };
    //--- Create:
    for (var i=0; i<map.layers.length; i++) {
        
        if (!map.layers[i].visible) continue; //--- Create only visible:

        var worldLayer = map.createLayer(i, this.game.width, this.game.height, this.group),
            layer      = worldLayer.layer;
        this.layers.all.push(worldLayer); //--- Keep all
        if (layer.properties) {
            //--- Platforms:
            if (layer.properties['platform']) {
                this.layers.platforms.push(worldLayer);
                //--- Find collision tiles:
                var collisions = []; //console.log(layer.data);
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) collisions.push(layer.data[row][cell].index); 
                    }
                }
                //--- Set collisions:
                if (collisions.length > 0) 
                    map.setCollision(collisions, true, i);
            }
            //--- Stairs:
            if (layer.properties['stair']) { 
                this.layers.stairs.push(worldLayer);
            }
            //--- Prizes:
            if (layer.properties['prize']) {
                var prizes = this.prizes = this.game.add.group(this.group);
                    prizes.enableBody = true;
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) {
                            var tile    = layer.data[row][cell],
                                sprite,
                                stateId = ['prizes', layer.name, row, cell]; //<-- ID for StateStorage
                            if (!stateStorage.get(stateId)) {
                                //--- Create the sprite if it was not saved:
                                sprite = this.makeSpriteFromTile(tile, this.map, this.game);
                                sprite.x += this._maps[mapName].layers[layer.name].offsetx || 0;   //<-- Layer offset bug fix
                                sprite.y += this._maps[mapName].layers[layer.name].offsety || 0;   //<-- Layer offset bug fix
                                sprite.stateId = stateId;
                                prizes.add(sprite);
                                //------------------------------------------
                            }
                            tile.index = -1; //--- clear tile
                        }
                    }
                }                        
            }
            //--- Blocks:
            if (layer.properties['block']) {
                var blocks = this.blocks = this.game.add.group(this.group);
                    blocks.enableBody    = true;
                for (var row in layer.data) {
                    for (var cell in layer.data[row]) {
                        if (layer.data[row][cell].index !== -1) {
                            var tile    = layer.data[row][cell],
                                sprite  = this.makeSpriteFromTile(tile, this.map, this.game),
                                stateId = ['blocks', layer.name, row, cell]; //<-- ID for StateStorage
                            sprite.x += this._maps[mapName].layers[layer.name].offsetx || 0;  //<-- Layer offset bug fix
                            sprite.y += this._maps[mapName].layers[layer.name].offsety || 0;  //<-- Layer offset bug fix
                            sprite.stateId = stateId;
                            //--- Move block to saved position: 
                            var savedBlock = stateStorage.get(stateId);
                            if (savedBlock) {
                                sprite.x = savedBlock[3] || sprite.x;
                                sprite.y = savedBlock[4] || sprite.y;
                            }
                            //---------------------------------
                            blocks.add(sprite);
                            this.blockManager.setBlockProperties(sprite, tile);
                            tile.index = -1; //--- clear tile
                        }
                    }
                }
            }
            //--- Goods:
            if (layer.properties['goods']) {
                this.layers.goods.push(worldLayer);
            }
        }
    };

    //--- Remove & Add saved tiles:
    var savedTiles = stateStorage.getSection('tiles');
    for (var id in savedTiles) {
        var data = savedTiles[id];
        switch (data[3]) {
            case 'add': //console.log('add:',data[4], data[1], data[2], data[0]);
                //                             index      x         y      layer                     
                var newtile = this.map.putTile(data[4], data[1], data[2], data[0]);
                if (data[5]) newtile.properties = data[5];
                break;
            case 'remove': //console.log('remove:',data[1], data[2], data[0]);
                //                    x        y      layer
                this.map.removeTile(data[1], data[2], data[0]);
                break;
        }
    }
    //---------------------------
    
    //--- Resize the world (by the first):
    if (this.layers.all[0])
        this.layers.all[0].resizeWorld(); //console.log(this.map.getLayerIndex('Platforms'));

    //--- Start point:
    this.startPoint = { x:this.game.width/2 , y:this.game.height/2 };

    //--- Game objects:
    this.objects = {
        doors: {}
    };
    for (var name in map.objects) {
        var objs = map.objects[name];
        for (var j in objs) {
            var obj  = objs[j];
            var prop = Phaser.Utils.extend(true, {}, this._maps[mapName].objects[name].properties);
                obj.properties = Phaser.Utils.extend(true, prop, obj.properties);
            //--- Start point:
            if (obj.type == 1) {
                this.startPoint = { x:obj.x, y:obj.y };
            }
            //--- Exit point:
            if (obj.type == 2) {
                this.exitPoint = { x:obj.x, y:obj.y };
            }                    
            //--- Door & Gates:
            if (obj.properties && (typeof(obj.properties.lock) != 'undefined' || obj.properties.gate_target)) {
                //--- StateStorage:
                    var stateId = ['openedDoors', name, obj.name];
                    //--- Delete the lock if door was opened:
                    if (stateStorage.get(stateId)) { delete obj.properties.lock; }
                    //--- Save only locked doors:
                    if (typeof(obj.properties.lock) != 'undefined') { obj.stateId = stateId; }
                //--- Add the door:
                this.objects.doors[obj.name] = obj;
            }
            //----------
        };
    };
    
    return this.map;
};

//------------------------------------------------------------------------------
// Scene main methods
//------------------------------------------------------------------------------

__theClass.prototype.preload = function (game) {
    
    this.game = game;
    
    // Level tilemaps: --------------------------------------------------
    if (this.maps && typeof(this.maps) === 'object') {
        this._maps = {};
        for (var mapName in this.maps) {
            this._maps[mapName] = {};
            if (!this.mainMapName) this.mainMapName = mapName;
            //console.log('level name:'+mapName+' : '+levelMaps[mapName]);
            var levelMap = require(this.maps[mapName]); 
            //--- Bug fix:
            for (var i in levelMap.layers) {
                var oname;
                if (levelMap.layers[i].type === "tilelayer")   oname = 'layers';
                if (levelMap.layers[i].type === "objectgroup") oname = 'objects';
                var layer = this._maps[mapName][oname] = this._maps[mapName][oname] || {};
                    layer[levelMap.layers[i].name] = levelMap.layers[i];
                
            }
            //---
            this.game.load.tilemap(mapName, null, levelMap, Phaser.Tilemap.TILED_JSON);
            for (var i=0; i<levelMap.tilesets.length; i++) {
                var tileset  = levelMap.tilesets[i],
                    image    = tileset.image;
                image = image.replace(new RegExp('^[\.\/]*' + RegExp.escape(this.assetsRootPath)), this.assetsRootPath);
                //this.game.load.image(tileset.name, image);  //console.log(tileset);
                this.game.load.spritesheet(tileset.name, image, tileset.tilewidth, tileset.tileheight);  //console.log(tileset);
            }
        }
    }
   
};

//__theClass.prototype.create = function (options) {
//};

__theClass.prototype.update = function () {
    
    //--- Collide blocks & platforms:
    this.game.physics.arcade.collide(this.blocks, this.blocks, null, null,  this);
    for (var i in this.layers.platforms) 
        this.game.physics.arcade.collide(this.blocks, this.layers.platforms[i], function(block, platform) {}, null, this);

};

//==============================================================================
// Exports module values:
//==============================================================================

module.exports = {
    
    /**
     * The class to inherit
     * 
     * example:
     * 
     * function childClass() {
     *      theclass.apply(this, arguments);
     * }
     * 
     * childClass.prototype = Object.create(theclass.prototype);
     * childClass.prototype.constructor = childClass;
     * 
     */
    theclass: __theClass,
    
    /**
     * The class factory
     * 
     * @param   {object} options The JS object with initial class parameters
     * @returns {object}         A new instance of this class
     */
    create: function (options) { //, id) {
        return new __theClass(options);
    //    if (!id)
    //        id = instanceDefaultId;
    //    if (!instances[id]) {
    //        instances[id] = new __theClass(options);
    //        instances[id].id = id;
    //    } else {
    //        instances[id]._init(options);
    //    }
    //    return instances[id];

    }//,
    
    //getInstances: function () {
    //    return instances;
    //}

};